Session 04: Metasprites & Animation
Date: 2026-01-31
================================================================================

GOAL
----
Replace the single 8x8 placeholder sprite with an animated Mega Man character
using multi-tile metasprites. The character stands idle when no input is pressed
and plays a 3-frame running animation when the D-pad is pressed left or right.
Horizontal flipping handles left-facing movement without needing extra tiles.

================================================================================

WHAT ARE METASPRITES? (Implementation)
--------------------------------------
Session 03 introduced the concept. This session implements it.

A metasprite is a group of hardware sprites arranged to look like one larger
character. Our Mega Man is 16x24 pixels (2 tiles wide, 3 tiles tall), using
6 hardware sprites per frame.

Each metasprite is defined as a data table in RODATA:

    MetaStand:
        ;    Y-off, Tile, Attr, X-off
        .byte $00,  $00,  $00,  $00   ; top-left
        .byte $00,  $01,  $00,  $08   ; top-right
        .byte $08,  $10,  $00,  $00   ; mid-left
        .byte $08,  $11,  $00,  $08   ; mid-right
        .byte $10,  $20,  $00,  $00   ; bot-left
        .byte $10,  $21,  $00,  $08   ; bot-right
        .byte $80                      ; end marker

The 4 bytes per sub-sprite are:
  - Y offset from anchor point
  - Tile index (in the sprite pattern table)
  - Attribute byte (palette, flip bits, priority)
  - X offset from anchor point

The $80 byte terminates the list. A rendering routine iterates this table,
adds the anchor position (sprite_x, sprite_y) to each offset, and writes
the result to the OAM buffer at $0200.

================================================================================

SPLIT PATTERN TABLES
--------------------
The NES has 8KB of CHR-ROM divided into two 4KB pattern tables:

  Pattern Table 0 ($0000-$0FFF): 256 tiles
  Pattern Table 1 ($1000-$1FFF): 256 tiles

PPUCTRL (register $2000) controls which table is used for what:
  Bit 4: Background pattern table (0 = table 0, 1 = table 1)
  Bit 3: Sprite pattern table     (0 = table 0, 1 = table 1)

Previously, both background and sprites used Pattern Table 0. Now we split:
  - Pattern Table 0: Background tiles (font A-Z for "HELLO WORLD!")
  - Pattern Table 1: Sprite tiles (Mega Man poses)

PPUCTRL changed from %10000000 to %10001000 (bit 3 set).

In the CHARS segment of the assembly:
  1. Inline .byte data for 34 font tiles (544 bytes)
  2. .res padding to fill Pattern Table 0 to exactly 4096 bytes
  3. .incbin "assets/chr/megaman_sprites.chr" for Pattern Table 1 (4096 bytes)

This keeps the font editable in assembly while loading sprite art from a
binary file generated by the asset pipeline.

================================================================================

TILE INDEX MAPPING
------------------
In a 128-pixel-wide CHR image (16 tiles per row), the tile index for a tile
at grid position (column, row) is:

    tile_index = row * 16 + column

Our 4 Mega Man poses are packed side by side in the top 3 rows:

    Cols:    0-1     2-3     4-5     6-7
    Row 0-2: Stand   Run1    Run2    Run3

So the tile indices for each pose are:

    Pose    | Top-L | Top-R | Mid-L | Mid-R | Bot-L | Bot-R
    --------|-------|-------|-------|-------|-------|------
    Stand   |  $00  |  $01  |  $10  |  $11  |  $20  |  $21
    Run 1   |  $02  |  $03  |  $12  |  $13  |  $22  |  $23
    Run 2   |  $04  |  $05  |  $14  |  $15  |  $24  |  $25
    Run 3   |  $06  |  $07  |  $16  |  $17  |  $26  |  $27

Note how tiles in a 3-row-tall sprite are NOT sequential. The top-left is
$00 but the tile directly below it is $10 (next row of 16). This is because
CHR tiles are laid out left-to-right across the full 128-pixel width before
wrapping to the next row. Understanding this mapping is essential for writing
correct metasprite tables.

================================================================================

TARGETED SPRITE EXTRACTION (tools/extract_poses.py)
----------------------------------------------------
Session 03's extract_sprites.py does bulk extraction — it grabs every sprite
it can find and packs them all. For animation, we need precise control over
which poses end up at which tile indices.

extract_poses.py solves this:

    python3 tools/extract_poses.py input.png output.png \
        --stand 45 --run 52 55 56

Workflow:
  1. Runs the same BFS sprite detection as extract_sprites.py
  2. Picks specific sprites by index (--stand and --run flags)
  3. Centers each in a 16x24 pixel box (crops if wider, pads if narrower)
  4. Quantizes to a shared 4-color palette
  5. Packs the 4 poses onto a 128x128 canvas in a known grid layout
  6. Outputs a PNG ready for png2chr.py

The --list flag shows all detected sprites without extracting:

    python3 tools/extract_poses.py assets/raw/8bitmegaman.png /dev/null --list

This lets you browse sprite indices and pick the right ones.

Full pipeline:
    python3 tools/extract_poses.py \
        assets/raw/8bitmegaman.png assets/raw/megaman_poses.png
    python3 tools/png2chr.py \
        assets/raw/megaman_poses.png assets/chr/megaman_sprites.chr
    make

================================================================================

PALETTE BRIGHTNESS SEPARATION
------------------------------
A subtle but important issue: png2chr.py sorts colors PER TILE by brightness
to assign 2-bit color indices. For this to produce consistent indices across
all tiles in a metasprite, the 4 palette colors must have clearly separated
brightness values.

Our extracted palette:
  Index 0: RGB(0, 0, 0)       brightness ≈ 0    (background/transparent)
  Index 1: RGB(24, 24, 24)    brightness ≈ 24   (outline)
  Index 2: RGB(0, 166, 249)   brightness ≈ 113  (body blue)
  Index 3: RGB(252, 236, 203) brightness ≈ 233  (skin/highlight)

The original outline color was RGB(5, 5, 5) — too close to the background
at RGB(0, 0, 0). This would cause png2chr.py to inconsistently assign
indices between tiles (some tiles might swap indices 0 and 1). The fix:
bump any outline color with brightness < 20 up to RGB(24, 24, 24).

On the NES side, both index 0 (transparent) and index 1 (outline) map to
NES color $0F (black), so the brightness bump in the PNG doesn't affect
the final appearance — it only ensures correct CHR encoding.

================================================================================

HORIZONTAL FLIPPING
-------------------
The NES PPU can flip individual 8x8 sprites horizontally via bit 6 of the
OAM attribute byte. To flip an entire metasprite (so Mega Man faces left),
two things must happen:

1. Set the H-flip bit ($40) on every sub-sprite's attribute.

2. Mirror the X offsets. For a 16-pixel-wide metasprite (2 tiles):

       mirrored_x_offset = 8 - original_x_offset

   This swaps the left and right tile columns:
       offset 0 → 8  (left tile moves to right position)
       offset 8 → 0  (right tile moves to left position)

   The formula generalizes to:
       mirrored = (metasprite_width - tile_width) - original

The H-flip bit tells the PPU to mirror each individual 8x8 tile's pixels,
while the offset mirroring repositions the tiles so the full character
appears correctly reflected. Combined, the metasprite looks like a proper
left-facing sprite without needing any extra tile data in CHR-ROM.

In 6502 assembly:

    ; Right-facing: X = sprite_x + x_offset
    lda (meta_ptr), y    ; x_offset
    clc
    adc sprite_x

    ; Left-facing: X = sprite_x + (8 - x_offset)
    lda #$08
    sec
    sbc (meta_ptr), y    ; A = 8 - x_offset
    clc
    adc sprite_x

================================================================================

ANIMATION STATE MACHINE
-----------------------
The animation system tracks 4 zero-page variables:

    facing_dir:  0 = right, 1 = left
    anim_state:  0 = idle,  1 = running
    anim_frame:  current frame index (0, 1, or 2 for running)
    anim_timer:  counts frames until next animation tick

Each NMI (60 Hz), the UpdateAnimation subroutine:

  1. Reads the controller state
  2. If no left/right input: transition to idle (reset frame/timer)
  3. If left/right pressed: transition to running (reset on state change)
  4. If already running: increment timer; when it hits ANIM_SPEED_RUN (6),
     advance to next frame and wrap at 3
  5. Look up the metasprite pointer for the current state + frame
  6. Tail-call DrawMetasprite

State transitions reset anim_frame and anim_timer to 0, so the animation
always starts cleanly from frame 0 when you begin or stop moving.

Frame pointer lookup uses split low/high byte tables:

    RunFramesL:  .byte <MetaRun1, <MetaRun2, <MetaRun3
    RunFramesH:  .byte >MetaRun1, >MetaRun2, >MetaRun3

    ldx anim_frame
    lda RunFramesL, x
    sta meta_ptr
    lda RunFramesH, x
    sta meta_ptr+1

This is the standard 6502 pattern for indexing into a table of 16-bit
pointers — you can't store 16-bit values directly, so you split them
into parallel low-byte and high-byte arrays.

================================================================================

SUBROUTINE REFACTORING
----------------------
The previous NMI handler had all logic inline. This session refactors it
into named subroutines called with jsr/rts:

    NMI:
        ; OAM DMA (must stay inline, runs during VBlank)
        jsr ReadControllerSub
        ; Update facing direction (inline, 10 instructions)
        jsr MovePlayer
        jsr UpdateAnimation    ; also calls DrawMetasprite
        ; Reset scroll (inline)
        rti

Benefits:
  - Each routine is self-contained and testable in isolation
  - Easier to read and modify
  - Labels with @ prefix are local to their enclosing subroutine
    (ca65 feature: @Loop inside MovePlayer won't clash with @Loop
    inside DrawMetasprite)

Cost: jsr/rts adds 12 CPU cycles per call (6 each). With 4 subroutine
calls that's 48 extra cycles — negligible within the NMI's ~2270 cycle
VBlank budget on NTSC.

UpdateAnimation uses a "tail call" optimization: instead of calling
DrawMetasprite with jsr and then rts, it jumps directly with jmp.
DrawMetasprite's rts then returns to UpdateAnimation's caller (the NMI).
This saves 12 cycles and one level of stack depth.

================================================================================

OAM BUFFER MANAGEMENT
---------------------
The DrawMetasprite routine manages the full OAM buffer ($0200-$02FF):

  1. Writes 6 sub-sprites (24 bytes) for the current metasprite frame
  2. Hides all remaining sprites (58 sprites × 4 bytes) by setting Y = $FE

Hiding unused sprites is critical. If leftover sprite data from previous
frames remains in OAM, ghost sprites appear on screen. Setting Y to $FE
moves them off the visible area (the NES screen is 240 scanlines, and
sprites at Y ≥ 240 are hidden).

The hide loop uses X as both the counter and the OAM offset. When X wraps
from $FC to $00 (after 64 sprites × 4 bytes = 256), the loop terminates.

================================================================================

NES COLOR PALETTE MAPPING
-------------------------
The sprite palette maps CHR color indices to NES hardware colors:

    CHR Index | Purpose           | NES Color | Hex
    ----------|-------------------|-----------|-----
    0         | Transparent       | (n/a)     | $0F
    1         | Outline (black)   | Black     | $0F
    2         | Body              | Med. blue | $11
    3         | Skin/highlights   | Lt. peach | $36

Index 0 is always transparent for sprites (the PPU ignores it regardless
of what color value you assign). Setting it to $0F is convention.

These NES color values are indices into the NES's fixed 64-color palette,
not RGB values. The exact appearance depends on the TV/emulator. Common
reference charts are available online ("NES palette chart").

================================================================================

FILES CREATED/MODIFIED
----------------------
  tools/extract_poses.py        NEW    Targeted pose extractor
  assets/raw/megaman_poses.png  NEW    128x128 PNG, 4 poses in known grid
  assets/chr/megaman_sprites.chr NEW   4KB CHR binary for Pattern Table 1
  hello.asm                     MOD    Metasprite system, animation, split CHR
  Makefile                      MOD    Added CHR build dependency

================================================================================

PROJECT DIRECTORY STRUCTURE (UPDATED)
--------------------------------------
  hello.asm             Main 6502 assembly source
  nes.cfg               Linker configuration
  Makefile              Build system
  hello.nes             Output ROM (built)
  assets/
    raw/
      8bitmegaman.png        Source spritesheet (322x405, full color)
      megaman_tiles.png      Bulk extraction output (session 03)
      megaman_poses.png      Targeted extraction: 4 poses, 128x128
    chr/
      megaman.chr            Bulk CHR (session 03, 8KB, not used in build)
      megaman_sprites.chr    Targeted CHR (4KB, used via .incbin)
  tools/
    png2chr.py               PNG → CHR binary converter
    extract_sprites.py       Bulk sprite extractor
    extract_poses.py         Targeted pose extractor
    convert.sh               Convenience wrapper
  sessions/
    session-01-hello-world.txt
    session-02-sprites-and-input.txt
    session-03-spritesheet-tooling.txt
    session-04-metasprites-and-animation.txt   (this file)

================================================================================

TESTING
-------
Load hello.nes in an NES emulator (Mesen, FCEUX, Nestopia):
  - Mega Man stands idle when no input is pressed
  - Press Right: runs right with 3-frame animation cycling
  - Press Left: runs left (sprite flipped horizontally)
  - Release D-pad: returns to standing idle pose
  - Character stays within screen bounds

If the wrong sprites were extracted, re-run with different indices:
    python3 tools/extract_poses.py assets/raw/8bitmegaman.png \
        assets/raw/megaman_poses.png --list
    # Pick indices from the list, then:
    python3 tools/extract_poses.py assets/raw/8bitmegaman.png \
        assets/raw/megaman_poses.png --stand N --run N N N
    python3 tools/png2chr.py assets/raw/megaman_poses.png \
        assets/chr/megaman_sprites.chr
    make

================================================================================

NEXT STEPS
----------
  - Gravity and jumping (accumulator-based velocity, ground detection)
  - Background scrolling for side-scrolling gameplay
  - Collision detection with background tiles
  - Multiple sprite palettes (face uses different colors than body)
  - Sound effects via the APU (jump sound, landing sound)
  - Enemy sprites and basic AI patterns
  - CHR bank switching for more sprite variety (requires mapper upgrade)
